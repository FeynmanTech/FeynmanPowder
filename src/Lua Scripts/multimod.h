#ifdef LUACONSOLE

	const char* multiplayermod_luac = ""
"mmod = mmod or {}\n"
"\n"
"function getvarvalue (name, level)\n"
"    local value, found\n"
"\n"
"    -- try local variables\n"
"    local i = 1\n"
"    while true do\n"
"        local n, v = debug.getlocal(level, i)\n"
"        if not n then break end\n"
"        if n == name then\n"
"            value = v\n"
"            found = true\n"
"        end\n"
"        i = i + 1\n"
"    end\n"
"    if found then return value end\n"
"\n"
"      -- try upvalues\n"
"    local func = debug.getinfo(level).func\n"
"    print(func)\n"
"    i = 1\n"
"    while true do\n"
"        local n, v = debug.getupvalue(func, i)\n"
"        if not n then break end\n"
"        if n == name then return v end\n"
"        i = i + 1\n"
"    end\n"
"\n"
"      -- not found; get global\n"
"    return getfenv(func)[name]\n"
"end\n"
"\n"
"function setvarvalue (name, level, value)\n"
"    local found\n"
"\n"
"    -- try local variables\n"
"    local i = 1\n"
"    while true do\n"
"        local n, v = debug.getlocal(level, i)\n"
"        if not n then break end\n"
"        if n == name then\n"
"            found = true\n"
"        end\n"
"        i = i + 1\n"
"    end\n"
"    if found then debug.setlocal(level, i, value) end\n"
"\n"
"      -- try upvalues\n"
"    local func = debug.getinfo(level).func\n"
"    i = 1\n"
"    while true do\n"
"        local n, v = debug.getupvalue(func, i)\n"
"        if not n then break end\n"
"        if n == name then debug.setupvalue(func, i, value) break end\n"
"        i = i + 1\n"
"    end\n"
"\n"
"      -- not found; get global\n"
"    return getfenv(func)[name]\n"
"end\n"
"\n"
"local changed = false\n"
"\n"
"local nickInput = ui_inputbox.new(5, 380 - 5 - 10, 100, 10)\n"
"\n"
"local nickButton = ui_button.new(107, 380 - 5 - 10, 16, 10,\n"
"    function() chatcommands[\"nick\"](mmod.chatwindow, nil, {nickInput.currentline}) end,\n"
"\"Ok\")\n"
"\n"
"tpt.register_step(function()\n"
"    nickInput:draw()\n"
"    nickButton:draw()\n"
"end)\n"
"\n"
"tpt.register_keypress(function(k, n, m, e) nickInput:textprocess(k, n, m, e) end)\n"
"\n"
"tpt.register_mouseclick(function(x, y, b, e)\n"
"    if x > 5 and x < 105 and y > 380 - 5 - 10 and y < 380 - 5 then\n"
"        nickInput:setfocus(true)\n"
"        return false\n"
"    elseif x > 107 and x < 107 + 16 and y > 380 - 5 - 10 and y < 380 - 5 then\n"
"        nickButton:process(x, y, b, e)\n"
"        return false\n"
"    else\n"
"        nickInput:setfocus()\n"
"    end\n"
"end)\n"
"\n"
"-- Run after one frame-only works this way for some reason\n"
"local run = 1\n"
"function TPTMP_MOD_INIT()\n"
"    if run == 2 then\n"
"\n"
"        local name = tpt.get_name\n"
"        chatcommands = chatcommands or {}\n"
"        chatcommands[\"nick\"] = function(self, msg, args)\n"
"            if tpt.get_name() == args[1] then\n"
"                chatcommands.quit()\n"
"                chatcommands.connect(self, nil, {})\n"
"            else\n"
"                tpt.get_name = function() return tostring(args[1]) end\n"
"                chatcommands.quit()\n"
"                chatcommands.connect(self, nil, {})\n"
"                tpt.get_name = name\n"
"            end\n"
"        end\n"
"\n"
"        chatcommands[\"__con\"] = chatcommands[\"connect\"]\n"
"\n"
"        chatcommands[\"connect\"] = function(self, msg, args)\n"
"            self = self or getvarvalue(\"chatwindow\", 3)\n"
"            chatcommands[\"__con\"](self, msg, args)\n"
"            local autojoinChannel\n"
"            local f = io.open(\"autojoin.multi\", \"r\")\n"
"            if f then\n"
"                autojoinChannel = f:read(\"*all\")\n"
"                if string.len(autojoinChannel) > 0 then\n"
"                    self:addline(\"Autojoining \" .. autojoinChannel, 50, 50, 255)\n"
"                end\n"
"            end\n"
"            if autoJoinChannel then\n"
"                chatcommands[\"join\"](self, msg, {autojoinChannel})\n"
"            end\n"
"            --mmod.con = getvarvalue(\"con\", 3)\n"
"            --mmod.chatwindow = self\n"
"            --mmod.con.__getcmds = function(n) return getvarvalue(\"dataCmds\", n or 3) end\n"
"            --setvarvalue(\"con\", 3, mmod.con)\n"
"        end\n"
"\n"
"        chatcommands[\"autojoin\"] = function(self, msg, args)\n"
"            local f = io.open(\"autojoin.multi\", \"w\")\n"
"            if string.len(args[1]) > 0 then\n"
"                f:write(args[1])\n"
"            else\n"
"                f:write(\"\")\n"
"            end\n"
"            f:close()\n"
"            self:addline(\"Set autojoin channel to \" .. (args[1] or \"default\") .. \"!\", 255, 255, 50)\n"
"        end\n"
"\n"
"        chatcommands[\"getcmd\"] = function(self, msg, args)\n"
"            local f = getvarvalue(\"con\", 3)\n"
"            print(f.__getcmds(args[1]))\n"
"        end\n"
"\n"
"        function mmod.conSend(cmd,msg,endNull)\n"
"            if not mmod.con.connected then return false,\"Not connected\" end\n"
"            msg = msg or \"\"\n"
"            if endNull then msg = msg..\"\\0\" end\n"
"            if cmd then msg = string.char(cmd)..msg end\n"
"            --print(\"sent \"..msg)\n"
"            mmod.con.socket:settimeout(10)\n"
"            mmod.con.socket:send(msg)\n"
"            mmod.con.socket:settimeout(0)\n"
"        end\n"
"\n"
"        function mmod.createBrush(x, y, bx, by, e, b)\n"
"            bx, by = bx or 0, by or 0\n"
"            b = b or 0\n"
"            if x<sim.XRES and y<sim.YRES then x,y = sim.adjustCoords(x,y) end\n"
"            local b1,b2,b3 = math.floor(x/16),((x%16)*16)+math.floor(y/256),(y%256)\n"
"            mmod.conSend(32,string.char(b1,b2,b3))\n"
"            if bx > 255 then bx = 255 end\n"
"            if by > 255 then by = 255 end\n"
"            mmod.conSend(34,string.char(bx,by))\n"
"            mmod.conSend(37,string.char(math.floor(e/256),e%256))\n"
"            mmod.conSend(33,string.char(17)) -- 1*16 + 3 (button, event)\n"
"            mmod.conSend(33,string.char(18))\n"
"            mmod.conSend(33,string.char(19))\n"
"            sim.createParts(x, y, bx, by, e, b)\n"
"        end\n"
"\n"
"        function mmod.create(e, x, y)\n"
"            if x<sim.XRES and y<sim.YRES then x,y = sim.adjustCoords(x,y) end\n"
"            local b1,b2,b3 = math.floor(x/16),((x%16)*16)+math.floor(y/256),(y%256)\n"
"            mmod.conSend(32,string.char(b1,b2,b3))\n"
"            if bx > 255 then bx = 255 end\n"
"            if by > 255 then by = 255 end\n"
"            mmod.conSend(34,string.char(0, 0))\n"
"            mmod.conSend(37,string.char(math.floor(e/256),e%256))\n"
"            mmod.conSend(33,string.char(17)) -- 1*16 + 3 (button, event)\n"
"            mmod.conSend(33,string.char(18))\n"
"            mmod.conSend(33,string.char(19))\n"
"            tpt.create(e, x, y)\n"
"        end\n"
"\n"
"        tpt.unregister_step(TPTMP_MOD_INIT)\n"
"    else\n"
"        run = run + 1\n"
"    end\n"
"end\n"
"tpt.register_step(TPTMP_MOD_INIT)\n"
""
;
#endif
